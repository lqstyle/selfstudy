package com.example.demo1.proxy;

import net.sf.cglib.core.DebuggingClassWriter;
import net.sf.cglib.proxy.Enhancer;

/**
 * CgLibProxy$
 *
 * @author shuai
 * @date 2020/4/27$
 *
 *
 *
 * *****
 * 1. 如何保证消息不丢失
 *
 * 生产消息
 * 生产者发送消息至Broker，需要处理Broker的响应，不论是同步还是异步发送消息，
 * 同步和异步回调都需要做好try-catch，妥善的处理响应，
 * 如果Broker返回写入失败等错误消息，需要重试发送。
 * 当多次发送失败需要作报警，日志记录等。
 *
 * 这样就能保证在生产消息阶段消息不会丢失。
 *
 * 存储消息
 * 存储消息阶段需要在消息刷盘之后再给生产者响应，假设消息写入缓存中就返回响应，
 * 那么机器突然断电这消息就没了，而生产者以为已经发送成功了。
 *
 * 如果Broker是集群部署，有多副本机制，即消息不仅仅要写入当前Broker,
 * 还需要写入副本机中。那配置成至少写入两台机子后再给生产者响应。
 * 这样基本上就能保证存储的可靠了。一台挂了还有一台还在呢（假如怕两台都挂了..那就再多些）。
 *
 * 那假如来个地震机房机子都挂了呢？emmmmmm...大公司基本上都有异地多活。
 *
 * 那要是这几个地都地震了呢？emmmmmm...这时候还是先关心关心人吧。
 *
 * 消费消息
 * 这里经常会有同学犯错，有些同学当消费者拿到消息之后直接存入内存队列中就直接返回给Broker消费成功，这是不对的。
 *
 * 你需要考虑拿到消息放在内存之后消费者就宕机了怎么办。
 * 所以我们应该在消费者真正执行完业务逻辑之后，
 * 再发送给Broker消费成功，这才是真正的消费了。
 *
 * 所以只要我们在消息业务逻辑处理完成之后再给Broker响应，那么消费阶段消息就不会丢失。
 *
 *
 *
 * 小结一下：
 *
 * 可以看出，保证消息的可靠性需要三方配合。
 * 生产者需要处理好Broker的响应，出错情况下利用重试、报警等手段。
 *
 * Broker需要控制响应的时机，单机情况下是消息刷盘后返回响应，集群多副本情况下，即发送至两个副本及以上的情况下再返回响应。
 *
 * 消费者需要在执行完真正的业务逻辑之后再返回响应给Broker。
 *
 * 但是要注意消息可靠性增强了，性能就下降了，等待消息刷盘、多副本同步后返回都会影响性能。
 * 因此还是看业务，例如日志的传输可能丢那么一两条关系不大，因此没必要等消息刷盘再响应。
 *
 * 2. 如果处理重复消息
 * 我们先来看看能不能避免消息的重复。
 *
 * 假设我们发送消息，就转发，不管Broker的响应，那么我们发往Broker是不会重复的。
 *
 * 但是一般情况我们是不允许这样的，这样消息就完全不可靠了，我们的基本需求是消息至少得发到Broker上，
 * 那就得等Broker的响应，那么就可能存在Broker已经写入了，当时响应由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。
 *
 * 再看消费者消费的时候，假设我们消费者拿到消息消费了，业务逻辑已经走完了，事务提交了，此时需要更新Consumer offset了，
 * 然后这个消费者挂了，另一个消费者顶上，此时Consumer offset还没更新，于是又拿到刚才那条消息，业务又被执行了一遍。于是消息又重复了。
 *
 * 可以看到正常业务而言消息重复是不可避免的，因此我们只能从另一个角度来解决重复消息的问题。
 *
 * 关键点就是幂等。既然我们不能防止重复消息的产生，那么我们只能在业务上处理重复消息所带来的影响。
 *
 *
 *
 * 幂等处理重复消息
 * 幂等是数学上的概念，我们就理解为同样的参数多次调用同一个接口和调用一次产生的结果是一致的。
 *
 * 例如这条 SQL update t1 set money = 150 where id = 1 and money = 100; 执行多少遍money都是150，这就叫幂等。
 *
 * 因此需要改造业务处理逻辑，使得在重复消息的情况下也不会影响最终的结果。
 *
 * 可以通过上面我那条 SQL 一样，做了个前置条件判断，即money = 100情况，并且直接修改，更通用的是做个version即版本号控制，
 * 对比消息中的版本号和数据库中的版本号。
 *
 * 或者通过数据库的约束例如唯一键，例如insert into update on duplicate key...。
 *
 * 或者记录关键的key，比如处理订单这种，记录订单ID，假如有重复的消息过来，先判断下这个ID是否已经被处理过了，
 * 如果没处理再进行下一步。当然也可以用全局唯一ID等等。
 *
 * 基本上就这么几个套路，真正应用到实际中还是得看具体业务细节。
 *
 * 总结 ：消息重复从业务层面避免，保证幂等性
 * 1. 通过全局唯一id来判断是否消费国
 * 2. 通过唯一业务id标识
 * 3. 通过消息版本号和数据库的消息版本号
 * 4 通过数据库唯一键 insert into update on duplicate key
 *
 *
 *
 *
 * 3. 如何保证消息的有序性
 * 有序性分：全局有序和部分有序。
 *
 * 全局有序
 * 如果要保证消息的全局有序，首先只能由一个生产者往Topic发送消息，并且一个Topic内部只能有一个队列（分区）。
 * 消费者也必须是单线程消费这个队列。这样的消息就是全局有序的！
 *
 * 不过一般情况下我们都不需要全局有序，即使是同步MySQL Binlog也只需要保证单表消息有序即可。
 *
 * 部分有序
 * 因此绝大部分的有序需求是部分有序，部分有序我们就可以将Topic内部划分成我们需要的队列数，
 * 把消息通过特定的策略发往固定的队列中，然后每个队列对应一个单线程处理的消费者。
 * 这样即完成了部分有序的需求，又可以通过队列数量的并发来提高消息处理效率。
 *
 *
 *
 * 4. 如果处理消息堆积
 * 消息的堆积往往是因为生产者的生产速度与消费者的消费速度不匹配。
 * 有可能是因为消息消费失败反复重试造成的，也有可能就是消费者消费能力弱，渐渐地消息就积压了。
 *
 * 因此我们需要先定位消费慢的原因，如果是bug则处理 bug ，
 * 如果是因为本身消费能力较弱，我们可以优化下消费逻辑，比如之前是一条一条消息消费处理的，
 * 这次我们批量处理，比如数据库的插入，一条一条插和批量插效率是不一样的。
 *
 * 假如逻辑我们已经都优化了，但还是慢，那就得考虑水平扩容了，
 * 增加Topic的队列数和消费者数量，注意队列数一定要增加，
 * 不然新增加的消费者是没东西消费的。一个Topic中，一个队列只会分配给一个消费者。
 *
 * 当然你消费者内部是单线程还是多线程消费那看具体场景。不过要注意上面提到的消息丢失的问题，
 * 如果你是将接受到的消息写入内存队列之后，然后就返回响应给Broker，然后多线程向内存队列消费消息，
 * 假设此时消费者宕机了，内存队列里面还未消费的消息也就丢了
 */
public class CgLibProxy {

  public static void main(String[] args) {
    //在指定目录下生成动态代理类，我们可以反编译看一下里面到底是一些什么东西
    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "D:\\java\\java_workapace");

    //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
    Enhancer enhancer = new Enhancer();
    //设置目标类的字节码文件
    enhancer.setSuperclass(Dog.class);
    //设置回调函数
    enhancer.setCallback(new MyMethodInterceptor());

    //这里的creat方法就是正式创建代理类
    Dog proxyDog = (Dog) enhancer.create();
    //调用代理类的eat方法
    proxyDog.run("杨文杰");
  }
}